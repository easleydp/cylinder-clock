<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Three.js Embossed Text on Cylinder</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #111;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <script type="module">
      import * as THREE from "three";
      //   import { FontLoader } from "three/addons/loaders/FontLoader.js";
      import { FontLoader } from "three/examples/jsm/loaders/FontLoader.js";
      import { TextGeometry } from "three/addons/geometries/TextGeometry.js";
      import { TessellateModifier } from "three/addons/modifiers/TessellateModifier.js";

      let scene, camera, renderer, rotatingGroup;
      let cylinderMesh; // We don't need individual textMesh variables globally anymore

      // Configuration
      const cylinderRadius = 5;
      const cylinderLength = 30;
      const textSize = 3;
      const textExtrusion = 0.5;
      const baseCurveSegments = 16; // Base detail for letter shapes

      // Helper function to generate a text mesh deformed onto the cylinder
      function generateTextOnCylinder(font, textContentStr, baseAngle) {
        const geometryParams = {
          font: font,
          size: textSize,
          depth: textExtrusion,
          curveSegments: baseCurveSegments,
          bevelEnabled: false,
        };
        let textGeo = new TextGeometry(textContentStr, geometryParams);

        const tessellateModifier = new TessellateModifier(
          textSize / 24, // maxEdgeLength: e.g., textSize / 5 or a fixed value like 0.4. Adjust as needed.
          // Smaller values = more detail = more polygons.
          12 // maxIterations: How many times to repeat the subdivision. Default is often fine.
        );
        textGeo = tessellateModifier.modify(textGeo);

        textGeo.computeBoundingBox();
        const textBoundingBox = textGeo.boundingBox;
        const textWidth = textBoundingBox.max.x - textBoundingBox.min.x;
        const textHeight = textBoundingBox.max.y - textBoundingBox.min.y;

        const positions = textGeo.attributes.position.array;

        for (let i = 0; i < positions.length / 3; i++) {
          const idx = i * 3;
          const originalX = positions[idx];
          const originalY = positions[idx + 1];
          const originalZ = positions[idx + 2];

          // Map text's X to cylinder's length (world X-axis), centered
          const mappedX = originalX - textBoundingBox.min.x - textWidth / 2;

          // Map text's Y (height) and Z (extrusion) to cylinder's curved surface (YZ plane)
          const verticalOffsetInText =
            originalY - textBoundingBox.min.y - textHeight / 2;
          const angleOffsetForCharHeight =
            verticalOffsetInText / cylinderRadius;

          // Use the provided baseAngle for positioning this text line
          const currentWrappedAngle = baseAngle - angleOffsetForCharHeight;

          const effectiveRadius = cylinderRadius + originalZ; // originalZ is extrusion

          const mappedY = effectiveRadius * Math.cos(currentWrappedAngle);
          const mappedZ = effectiveRadius * Math.sin(currentWrappedAngle);

          positions[idx] = mappedX;
          positions[idx + 1] = mappedY;
          positions[idx + 2] = mappedZ;
        }

        textGeo.attributes.position.needsUpdate = true;
        textGeo.computeVertexNormals();

        // Material will be created once and passed or defined here
        const textMat = new THREE.MeshStandardMaterial({
          color: 0xffc107, // A warm yellow/gold
          metalness: 0.5,
          roughness: 0.4,
        });

        return new THREE.Mesh(textGeo, textMat);
      }

      function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(
          0,
          cylinderRadius * 0.5,
          cylinderRadius * 2.5 + cylinderLength * 0.3
        ); // Positioned to see the front/top
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);

        // Group for cylinder and text to rotate together
        rotatingGroup = new THREE.Group();
        scene.add(rotatingGroup);

        const cylinderGeo = new THREE.CylinderGeometry(
          cylinderRadius,
          cylinderRadius,
          cylinderLength,
          64,
          1
        );
        const cylinderMat = new THREE.MeshStandardMaterial({
          color: 0x607d8b,
          metalness: 0.3,
          roughness: 0.6,
        });
        cylinderMesh = new THREE.Mesh(cylinderGeo, cylinderMat);
        // Rotate the cylinder so its length is along the X-axis
        cylinderMesh.rotation.z = Math.PI / 2;
        rotatingGroup.add(cylinderMesh);

        loadAndCreateAllTexts();

        window.addEventListener("resize", onWindowResize, false);
        animate();
      }

      function loadAndCreateAllTexts() {
        const fontLoader = new FontLoader();
        const fontPath =
          "https://threejs.org/examples/fonts/helvetiker_regular.typeface.json";

        fontLoader.load(fontPath, function (font) {
          // Text 1: "WebGL Rocks!"
          const textContent1 = "WebGL Rocks!";
          const baseAngle1 = Math.PI / 2; // Front face (local +Z on YZ plane)
          const textMesh1 = generateTextOnCylinder(
            font,
            textContent1,
            baseAngle1
          );
          rotatingGroup.add(textMesh1);

          // Text 2: "Three.js Rocks!"
          const textContent2 = "Three.js Rocks!";
          // Opposite side: add PI (180 degrees) to the first angle
          const baseAngle2 = Math.PI / 2 + Math.PI; // Back face (local -Z on YZ plane)
          const textMesh2 = generateTextOnCylinder(
            font,
            textContent2,
            baseAngle2
          );
          rotatingGroup.add(textMesh2);
        });
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        requestAnimationFrame(animate);
        if (rotatingGroup) {
          rotatingGroup.rotation.x -= 0.005; // Negative speed for "upward" scroll of front face
        }
        renderer.render(scene, camera);
      }

      init();
    </script>
  </body>
</html>
