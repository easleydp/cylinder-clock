<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Three.js Embossed Text on Cylinder</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #111;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <script type="module">
      import * as THREE from "three";
      //   import { FontLoader } from "three/addons/loaders/FontLoader.js";
      import { FontLoader } from "three/examples/jsm/loaders/FontLoader.js";
      import { TextGeometry } from "three/addons/geometries/TextGeometry.js";
      import { TessellateModifier } from "three/addons/modifiers/TessellateModifier.js";
      import { MathUtils } from "three"; // Import MathUtils for euclideanModulo

      let scene, camera, renderer, rotatingGroup;
      let cylinderMesh;
      let loadedFont = null; // To store the loaded font globally
      const textLines = []; // Array to manage our text lines

      // Configuration
      const cylinderRadius = 5;
      const cylinderLength = 30;
      const textSize = 3;
      const textDepth = 0.1;
      const baseCurveSegments = 16;

      // Base angles for text positioning
      //   const baseAngleText1 = Math.PI / 2; // Front top (local +Z on YZ plane initially)
      //   const baseAngleText2 = Math.PI / 2 + Math.PI; // Back bottom (local -Z on YZ plane initially)
      const baseAngleText1 = Math.PI; // Front top (local +Z on YZ plane initially)
      const baseAngleText2 = 0; // Back bottom (local -Z on YZ plane initially)

      // Helper function to generate deformed text BufferGeometry
      async function generateTextGeometryOnCylinder(
        font,
        textContentStr,
        baseAngle
      ) {
        const geometryParams = {
          font: font,
          size: textSize,
          depth: textDepth,
          curveSegments: baseCurveSegments,
          bevelEnabled: false,
        };
        let textGeo = new TextGeometry(textContentStr, geometryParams);

        await scheduler.yield();
        const tessellateModifier = new TessellateModifier(
          textSize / 24, // maxEdgeLength: e.g., textSize / 5 or a fixed value like 0.4. Adjust as needed.
          // Smaller values = more detail = more polygons.
          12 // maxIterations: How many times to repeat the subdivision. Default is often fine.
        );
        // const tessellateModifier = new TessellateModifier(
        //   textSize / 12, // maxEdgeLength: e.g., textSize / 5 or a fixed value like 0.4. Adjust as needed.
        //   // Smaller values = more detail = more polygons.
        //   4 // maxIterations: How many times to repeat the subdivision. Default is often fine.
        // );
        textGeo = tessellateModifier.modify(textGeo);

        await scheduler.yield();
        textGeo.computeBoundingBox();
        const textBoundingBox = textGeo.boundingBox;
        const textWidth = textBoundingBox.max.x - textBoundingBox.min.x;
        const textHeight = textBoundingBox.max.y - textBoundingBox.min.y;

        const positions = textGeo.attributes.position.array;
        for (let i = 0; i < positions.length / 3; i++) {
          const idx = i * 3;
          const originalX = positions[idx],
            originalY = positions[idx + 1],
            originalZ = positions[idx + 2];

          // Map text's X to cylinder's length (world X-axis), centered
          const mappedX = originalX - textBoundingBox.min.x - textWidth / 2;

          // Map text's Y (height) and Z (extrusion) to cylinder's curved surface (YZ plane)
          const verticalOffsetInText =
            originalY - textBoundingBox.min.y - textHeight / 2;
          const angleOffsetForCharHeight =
            verticalOffsetInText / cylinderRadius;
          const currentWrappedAngle = baseAngle - angleOffsetForCharHeight;
          const effectiveRadius = cylinderRadius + originalZ; // originalZ is extrusion depth from TextGeometry

          positions[idx] = mappedX;
          positions[idx + 1] = effectiveRadius * Math.cos(currentWrappedAngle);
          positions[idx + 2] = effectiveRadius * Math.sin(currentWrappedAngle);
        }
        textGeo.attributes.position.needsUpdate = true;
        await scheduler.yield();
        textGeo.computeVertexNormals();
        return textGeo;
      }

      async function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(
          0,
          cylinderRadius * 0.5,
          cylinderRadius * 2.5 + cylinderLength * 0.3
        ); // Positioned to see the front/top
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7); // Slightly increased ambient
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 2.0); // Slightly increased directional
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);

        // Group for cylinder and text to rotate together
        rotatingGroup = new THREE.Group();
        scene.add(rotatingGroup);

        const cylinderGeo = new THREE.CylinderGeometry(
          cylinderRadius,
          cylinderRadius,
          cylinderLength,
          64,
          1
        );
        const cylinderMat = new THREE.MeshStandardMaterial({
          color: 0x607d8b,
          metalness: 0.3,
          roughness: 0.6,
        });
        cylinderMesh = new THREE.Mesh(cylinderGeo, cylinderMat);
        // Rotate the cylinder so its length is along the X-axis
        cylinderMesh.rotation.z = Math.PI / 2;
        rotatingGroup.add(cylinderMesh);

        loadAndCreateAllTexts();

        window.addEventListener("resize", onWindowResize, false);
        animate(0);
      }

      async function loadAndCreateAllTexts() {
        const fontLoader = new FontLoader();
        const fontPath =
          "https://threejs.org/examples/fonts/helvetiker_regular.typeface.json";

        fontLoader.load(fontPath, async function (font) {
          loadedFont = font; // Store the loaded font globally

          const commonTextMaterial = new THREE.MeshStandardMaterial({
            color: 0xffc107,
            metalness: 0.5,
            roughness: 0.4,
          });

          // Text Line 1 Setup
          const textContentStrings1 = [
            "WebGL Magic!",
            "Rotate Me!",
            "Front View Text",
          ];
          const initialGeo1 = await generateTextGeometryOnCylinder(
            loadedFont,
            textContentStrings1[0],
            baseAngleText1
          );
          const mesh1 = new THREE.Mesh(initialGeo1, commonTextMaterial);
          rotatingGroup.add(mesh1);
          textLines.push({
            mesh: mesh1,
            contentStrings: textContentStrings1,
            currentStringIdx: 0,
            baseAngle: baseAngleText1,
            isRoundTheBack: Math.cos(0) > 0.1, // Initial check at angle 0
            needsUpdate: false,
          });

          // Text Line 2 Setup
          const textContentStrings2 = [
            "Three.js Power!",
            "See The Back?",
            "More Content Here",
          ];
          const initialGeo2 = await generateTextGeometryOnCylinder(
            loadedFont,
            textContentStrings2[0],
            baseAngleText2
          );
          const mesh2 = new THREE.Mesh(initialGeo2, commonTextMaterial);
          rotatingGroup.add(mesh2);
          textLines.push({
            mesh: mesh2,
            contentStrings: textContentStrings2,
            currentStringIdx: 0,
            baseAngle: baseAngleText2,
            isRoundTheBack: Math.cos(0) < -0.1, // Initial check at angle 0 (for local -Z facing part)
            needsUpdate: false,
          });
          console.log("Text lines initialized:", textLines);
        });
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      let lastTimestamp = 0;
      async function animate(timestamp) {
        const delta = timestamp - lastTimestamp;
        // Throttle animation loop to save CPU in case monitor refresh rate is too fast
        const maxRefreshRateHz = 30;
        if (delta < 1000 / maxRefreshRateHz) {
          requestAnimationFrame(animate);
          return;
        }
        // // Show actual refresh rate in console
        // if (lastTimestamp !== -1) {
        //   const refreshRate = Math.round(1000 / delta);
        //   console.log(`Refresh rate: ${refreshRate} Hz`);
        // }
        lastTimestamp = timestamp;

        if (loadedFont && textLines.length > 0) {
          // Ensure font and text lines are ready
          const rotationAngle = rotatingGroup.rotation.x;
          // Normalize angle to [0, 2PI) to make cos calculations predictable
          const normalizedAngle = MathUtils.euclideanModulo(
            rotationAngle,
            2 * Math.PI
          );

          textLines.forEach(async (line) => {
            let textIsCurrentlyRoundTheBack;
            // Determine if "round the back" based on its original local Z orientation and current rotation
            // Text at baseAngleText1 is on local +Z side of cylinder
            // Text at baseAngleText2 is on local -Z side of cylinder
            if (line.baseAngle === baseAngleText1) {
              // Originally local +Z
              textIsCurrentlyRoundTheBack = Math.cos(normalizedAngle) > 0.1; // World Z positive
            } else {
              // Originally local -Z
              textIsCurrentlyRoundTheBack = Math.cos(normalizedAngle) < -0.1; // World Z positive (because local -Z * cos becomes positive)
            }

            if (!line.isRoundTheBack && textIsCurrentlyRoundTheBack) {
              // Transitioned from view (or side) to fully round the back
              line.needsUpdate = true;
              // console.log(`Text for baseAngle ${line.baseAngle.toFixed(2)} went to back, scheduling update.`);
            }
            line.isRoundTheBack = textIsCurrentlyRoundTheBack;

            if (line.needsUpdate && line.isRoundTheBack) {
              line.currentStringIdx =
                (line.currentStringIdx + 1) % line.contentStrings.length;
              const newTextContent = line.contentStrings[line.currentStringIdx];

              console.log(
                `Updating text for baseAngle ${line.baseAngle.toFixed(
                  2
                )} to: "${newTextContent}"`
              );

              await scheduler.yield();
              const newGeo = await generateTextGeometryOnCylinder(
                loadedFont,
                newTextContent,
                line.baseAngle
              );

              await scheduler.yield();
              line.mesh.geometry.dispose(); // IMPORTANT: Dispose old geometry to free GPU memory
              line.mesh.geometry = newGeo; // Assign new geometry
              line.needsUpdate = false;
            }
          });
        }

        rotatingGroup.rotation.x -= 0.005;
        renderer.render(scene, camera);

        requestAnimationFrame(animate);
      }

      init();
    </script>
  </body>
</html>
