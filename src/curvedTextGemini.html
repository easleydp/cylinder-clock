<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Three.js Embossed Text on Cylinder</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #111;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <script type="module">
      import * as THREE from "three";
      import { FontLoader } from "three/examples/jsm/loaders/FontLoader.js";
      import { TextGeometry } from "three/addons/geometries/TextGeometry.js";

      let scene, camera, renderer, rotatingGroup;
      let cylinderMesh, textMesh;

      // Configuration
      const cylinderRadius = 5;
      const cylinderLength = 30; // This is the 'height' for CylinderGeometry, but it will be laid horizontally
      const textContent = "WebGL Rocks!";
      const textSize = 3; // Height of the text characters
      const textExtrusion = 0.5; // How much the text is "embossed"

      function init() {
        // Scene
        scene = new THREE.Scene();

        // Camera
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(
          0,
          cylinderRadius * 0.5,
          cylinderRadius * 2.5 + cylinderLength * 0.3
        ); // Positioned to see the front/top
        camera.lookAt(0, 0, 0);

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);

        // Group for cylinder and text to rotate together
        rotatingGroup = new THREE.Group();
        scene.add(rotatingGroup);

        // Cylinder
        // CylinderGeometry is created along the Y-axis by default.
        // We'll rotate the group later if needed, or build geometry assuming final orientation.
        // Let's make the cylinder's length align with the X-axis for this setup.
        const cylinderGeo = new THREE.CylinderGeometry(
          cylinderRadius,
          cylinderRadius,
          cylinderLength,
          64,
          1
        );
        const cylinderMat = new THREE.MeshStandardMaterial({
          color: 0x607d8b, // A bluish-grey
          metalness: 0.3,
          roughness: 0.6,
        });
        cylinderMesh = new THREE.Mesh(cylinderGeo, cylinderMat);
        // Rotate the cylinder so its length is along the X-axis
        cylinderMesh.rotation.z = Math.PI / 2;
        rotatingGroup.add(cylinderMesh);

        // Font Loading and Text Creation
        loadFontAndCreateText();

        // Handle window resize
        window.addEventListener("resize", onWindowResize, false);

        // Start animation
        animate();
      }

      function loadFontAndCreateText() {
        const fontLoader = new FontLoader();
        // Using a font from Three.js examples. Host your own or use a CDN.
        const fontPath =
          "https://threejs.org/examples/fonts/helvetiker_regular.typeface.json";

        fontLoader.load(fontPath, function (font) {
          const geometryParams = {
            font: font,
            size: textSize,
            depth: textExtrusion, // This is actually depth/extrusion for TextGeometry
            curveSegments: 12,
            bevelEnabled: false,
          };
          const textGeo = new TextGeometry(textContent, geometryParams);

          // Calculate text dimensions for centering and mapping
          textGeo.computeBoundingBox();
          const textBoundingBox = textGeo.boundingBox;
          const textWidth = textBoundingBox.max.x - textBoundingBox.min.x;
          const textHeight = textBoundingBox.max.y - textBoundingBox.min.y; // Actual height of generated letters

          const positions = textGeo.attributes.position.array;
          const normals = textGeo.attributes.normal.array; // We'll recompute later, but good to be aware of

          for (let i = 0; i < positions.length / 3; i++) {
            const idx = i * 3;
            const originalX = positions[idx]; // Corresponds to text's width dimension
            const originalY = positions[idx + 1]; // Corresponds to text's height dimension
            const originalZ = positions[idx + 2]; // Corresponds to text's extrusion dimension

            // 1. Map text's X to cylinder's length (which is along world X-axis)
            // We center the text along the cylinder's length
            const mappedX = originalX - textBoundingBox.min.x - textWidth / 2;

            // 2. Map text's Y (height) and Z (extrusion) to cylinder's curved surface (YZ plane)
            // We want the text on the "front" face (positive Z in world coordinates)
            // The text's original Y dimension (height of letters) will wrap slightly around the cylinder
            const verticalOffsetInText =
              originalY - textBoundingBox.min.y - textHeight / 2; // Center char height
            const angleAroundCylinder = verticalOffsetInText / cylinderRadius;

            // We want the text centered on the +Z face of the cylinder.
            // In YZ plane, +Z is at angle PI/2 (if +Y is angle 0).
            // Our text vertical motion (angleAroundCylinder) adjusts this.
            // A positive verticalOffsetInText (top of letter) should shift angle towards +Y.
            const targetAngle = Math.PI / 2 - angleAroundCylinder;

            // Embossing: originalZ (extrusion) increases radius
            const effectiveRadius = cylinderRadius + originalZ;

            const mappedY = effectiveRadius * Math.cos(targetAngle);
            const mappedZ = effectiveRadius * Math.sin(targetAngle);

            positions[idx] = mappedX;
            positions[idx + 1] = mappedY;
            positions[idx + 2] = mappedZ;
          }

          textGeo.attributes.position.needsUpdate = true;
          textGeo.computeVertexNormals(); // Crucial for correct lighting after deformation

          const textMat = new THREE.MeshStandardMaterial({
            color: 0xffc107, // A warm yellow/gold
            metalness: 0.5,
            roughness: 0.4,
          });
          textMesh = new THREE.Mesh(textGeo, textMat);

          // The text vertices are now calculated for a cylinder oriented along X-axis.
          // No additional rotation for the textMesh itself needed if cylinderMesh is also X-aligned.
          rotatingGroup.add(textMesh);
        });
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        requestAnimationFrame(animate);

        // Rotate the group around its X-axis (which is the cylinder's length axis)
        // Negative rotation to make the front face (+Z) roll "upwards" (towards +Y)
        if (rotatingGroup) {
          rotatingGroup.rotation.x -= 0.005; // Adjust speed as needed
        }

        renderer.render(scene, camera);
      }

      init();
    </script>
  </body>
</html>
