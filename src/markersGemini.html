<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Rotating Cylinder with Embossed Markers</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.165.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.165.0/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      let scene, camera, renderer, cylinderGroup;
      let cylinder;

      const cylinderRadius = 5;
      const cylinderHeight = 20;
      const cylinderRadialSegments = 64; // Increased for smoother cylinder surface for markers

      // Marker properties
      const markerColor = 0xaaaaaa; // Metallic grey for all markers
      const markerRadialHeight = 0.1; // How much the marker "sticks out" - the embossed depth

      const minorMarkerCircumferentialLength = 0.5; // Length along the cylinder's curve
      const minorMarkerAxialWidth = 0.3; // Width along the cylinder's length

      const majorMarkerCircumferentialLength =
        minorMarkerCircumferentialLength * 1.6;
      const majorMarkerAxialWidth = minorMarkerAxialWidth * 1.4;

      // Offset from cylinder ends to prevent markers from extending beyond
      const markerEndBuffer =
        Math.max(majorMarkerAxialWidth, minorMarkerAxialWidth) / 2 + 0.1; // Nudge in slightly more than half their max width

      function init() {
        // Scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);

        // Camera
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(0, 5, 15);

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(8, 15, 10);
        scene.add(directionalLight);
        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.3); // Softer fill
        directionalLight2.position.set(-8, -5, -10);
        scene.add(directionalLight2);

        // Cylinder Group
        cylinderGroup = new THREE.Group();
        scene.add(cylinderGroup);

        // Cylinder
        const cylinderGeometry = new THREE.CylinderGeometry(
          cylinderRadius,
          cylinderRadius,
          cylinderHeight,
          cylinderRadialSegments
        );
        const cylinderMaterial = new THREE.MeshStandardMaterial({
          color: 0x228b22,
          metalness: 0.4,
          roughness: 0.7,
        }); // Forest Green
        cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
        cylinder.rotation.z = Math.PI / 2; // Make horizontal along X-axis
        cylinderGroup.add(cylinder);

        // Create Markers
        createMarkers();

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        window.addEventListener("resize", onWindowResize, false);
        animate();
      }

      function createMarkers() {
        const numMajorMarkers = 5;
        const numMinorMarkersBetweenMajor = 4;
        const totalMarkersPerEnd =
          numMajorMarkers * (1 + numMinorMarkersBetweenMajor);
        const angleIncrement = (2 * Math.PI) / totalMarkersPerEnd;

        const markerMaterial = new THREE.MeshStandardMaterial({
          color: markerColor,
          metalness: 0.8,
          roughness: 0.3,
        });

        // Calculate actual positions for cylinder ends for markers (nudged inwards)
        const cylinderMarkerPlacementLength =
          cylinderHeight / 2 - markerEndBuffer;
        const markerPlacementXCoords = [
          -cylinderMarkerPlacementLength,
          cylinderMarkerPlacementLength,
        ];

        markerPlacementXCoords.forEach((xPosCyl) => {
          for (let i = 0; i < totalMarkersPerEnd; i++) {
            const isMajor = i % (numMinorMarkersBetweenMajor + 1) === 0;

            const currentAxialWidth = isMajor
              ? majorMarkerAxialWidth
              : minorMarkerAxialWidth;
            const currentCircumferentialLength = isMajor
              ? majorMarkerCircumferentialLength
              : minorMarkerCircumferentialLength;

            // Geometry: BoxGeometry(width, height, depth) -> X, Y, Z
            // We map: X = axialWidth, Y = radialHeight, Z = circumferentialLength
            const markerGeometry = new THREE.BoxGeometry(
              currentAxialWidth,
              markerRadialHeight,
              currentCircumferentialLength
            );
            const marker = new THREE.Mesh(markerGeometry, markerMaterial);

            const angle = i * angleIncrement;

            // Position markers on the circumference
            // Y and Z position calculated on the circle, accounting for marker's own radial height
            const yPos =
              (cylinderRadius + markerRadialHeight / 2) * Math.cos(angle);
            const zPos =
              (cylinderRadius + markerRadialHeight / 2) * Math.sin(angle);

            marker.position.set(xPosCyl, yPos, zPos);

            // Orient the marker:
            // The cylinder's main axis is the Group's X-axis.
            // We rotate the marker around this X-axis by 'angle'.
            // Due to our BoxGeometry mapping:
            // - Marker's local X-axis (axialWidth) remains aligned with the cylinder's axis.
            // - Marker's local Y-axis (radialHeight) becomes radial.
            // - Marker's local Z-axis (circumferentialLength) becomes tangential.
            marker.rotation.x = angle;

            cylinderGroup.add(marker);
          }
        });
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        requestAnimationFrame(animate);

        // Rotate the entire group around its X-axis
        // Negative rotation makes the side facing camera (+Z of cylinder) rotate upwards (+Y world)
        cylinderGroup.rotation.x -= 0.005;

        renderer.render(scene, camera);
      }

      init();
    </script>
  </body>
</html>
