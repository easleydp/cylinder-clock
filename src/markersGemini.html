<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Rotating Cylinder with Deformed Markers (Z-Fighting Fix)</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.165.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.165.0/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      let scene, camera, renderer, cylinderGroup;
      let cylinder;

      const cylinderRadius = 5;
      const cylinderHeight = 20;
      const cylinderRadialSegments = 64;

      const markerColor = 0x444444;
      const markerRadialHeight = 0.1; // Thickness of the marker

      const minorMarkerCircumferentialLength = 0.4;
      const minorMarkerAxialWidth = 0.5; // Width along the cylinder's length

      const majorMarkerCircumferentialLength =
        minorMarkerCircumferentialLength * 1.6;
      const majorMarkerAxialWidth = minorMarkerAxialWidth * 1.4;

      const markerEndBuffer =
        Math.max(majorMarkerAxialWidth, minorMarkerAxialWidth) / 2 + 0.02;

      const markerMaterial = new THREE.MeshStandardMaterial({
        color: markerColor,
        metalness: 0.4,
        roughness: 0.5,
      });

      function createDeformedMarkerGeometry(
        axialWidth,
        radialHeight,
        circumferentialLength,
        baseCylinderRadius,
        markerCenterX,
        markerCenterAngle
      ) {
        const geometry = new THREE.BufferGeometry();

        const epsilon = 0.001; // Small offset to prevent Z-fighting

        // The marker's bottom surface will be at baseCylinderRadius + epsilon
        // The marker's top surface will be at baseCylinderRadius + epsilon + radialHeight
        const actualBottomRadius = baseCylinderRadius + epsilon;
        const actualTopRadius = actualBottomRadius + radialHeight;

        // Calculate angular width based on the desired circumferential length
        // at the marker's intended visual mid-radius (before epsilon offset for Z-fighting)
        const visualMidRadius = baseCylinderRadius + radialHeight / 2;
        const angularWidth = circumferentialLength / visualMidRadius;

        const angleStart = markerCenterAngle - angularWidth / 2;
        const angleEnd = markerCenterAngle + angularWidth / 2;

        const xStart = markerCenterX - axialWidth / 2;
        const xEnd = markerCenterX + axialWidth / 2;

        // prettier-ignore
        const vertices = new Float32Array([
            // Bottom face (using actualBottomRadius)
            xStart, actualBottomRadius * Math.cos(angleStart), actualBottomRadius * Math.sin(angleStart), // p0
            xEnd,   actualBottomRadius * Math.cos(angleStart), actualBottomRadius * Math.sin(angleStart), // p1
            xStart, actualBottomRadius * Math.cos(angleEnd),   actualBottomRadius * Math.sin(angleEnd),   // p2
            xEnd,   actualBottomRadius * Math.cos(angleEnd),   actualBottomRadius * Math.sin(angleEnd),   // p3

            // Top face (using actualTopRadius)
            xStart, actualTopRadius * Math.cos(angleStart), actualTopRadius * Math.sin(angleStart), // p4
            xEnd,   actualTopRadius * Math.cos(angleStart), actualTopRadius * Math.sin(angleStart), // p5
            xStart, actualTopRadius * Math.cos(angleEnd),   actualTopRadius * Math.sin(angleEnd),   // p6
            xEnd,   actualTopRadius * Math.cos(angleEnd),   actualTopRadius * Math.sin(angleEnd)    // p7
        ]);

        // Consistent Counter-Clockwise (CCW) winding for faces (when viewed from the "outside" of
        // that face) is crucial for geometry.computeVertexNormals() to generate correct,
        // outward-pointing normals. Incorrect winding can lead to faces appearing dark or invisible.
        // prettier-ignore
        const indices = [
            // Bottom face (CCW from "below" marker, normal points towards cylinder axis / "down" locally)
            0, 1, 3,   0, 3, 2, // Quad p0-p1-p3-p2

            // Top face (CCW from "above" marker, normal points radially out from cylinder / "up" locally)
            4, 6, 7,   4, 7, 5, // Quad p4-p6-p7-p5

            // Side face at angleStart ("front" side along circumference, CCW from outside this face)
            0, 4, 5,   0, 5, 1, // Quad p0-p4-p5-p1

            // Side face at angleEnd ("back" side along circumference, CCW from outside this face)
            3, 6, 2,   3, 7, 6, // Quad p3-p2-p6-p7 (note vertex order for CCW)

            // Side face at xStart (axial "left", CCW from outside this face)
            0, 2, 6,   0, 6, 4, // Quad p0-p2-p6-p4

            // Side face at xEnd (axial "right", CCW from outside this face)
            1, 5, 7,   1, 7, 3  // Quad p1-p5-p7-p3
        ];

        geometry.setAttribute(
          "position",
          new THREE.BufferAttribute(vertices, 3)
        );
        geometry.setIndex(indices);
        geometry.computeVertexNormals();

        return geometry;
      }

      function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);

        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(0, cylinderRadius * 1.2, cylinderHeight * 0.75);
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
        directionalLight.position.set(10, 15, 10);
        directionalLight.castShadow = true; // Optional: for better lighting
        scene.add(directionalLight);
        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight2.position.set(-10, -5, -10);
        scene.add(directionalLight2);

        cylinderGroup = new THREE.Group();
        scene.add(cylinderGroup);

        const cylinderGeometry = new THREE.CylinderGeometry(
          cylinderRadius,
          cylinderRadius,
          cylinderHeight,
          cylinderRadialSegments,
          1,
          false
        );
        const cylinderMaterial = new THREE.MeshStandardMaterial({
          color: 0x228b22,
          metalness: 0.4,
          roughness: 0.7,
        });
        cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
        cylinder.rotation.z = Math.PI / 2;
        cylinderGroup.add(cylinder);

        createMarkers();

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        window.addEventListener("resize", onWindowResize, false);
        animate();
      }

      function createMarkers() {
        const numMajorMarkers = 5;
        const numMinorMarkersBetweenMajor = 4;
        const totalMarkersPerEnd =
          numMajorMarkers * (1 + numMinorMarkersBetweenMajor);
        const baseAngleIncrement = (2 * Math.PI) / totalMarkersPerEnd;

        const cylinderMarkerPlacementX = cylinderHeight / 2 - markerEndBuffer;
        const markerXPositions = [
          -cylinderMarkerPlacementX,
          cylinderMarkerPlacementX,
        ];

        markerXPositions.forEach((markerCenterX) => {
          for (let i = 0; i < totalMarkersPerEnd; i++) {
            const isMajor = i % (numMinorMarkersBetweenMajor + 1) === 0;

            const axialWidth = isMajor
              ? majorMarkerAxialWidth
              : minorMarkerAxialWidth;
            const circumferentialLength = isMajor
              ? majorMarkerCircumferentialLength
              : minorMarkerCircumferentialLength;

            const markerCenterAngle = i * baseAngleIncrement;

            const markerGeom = createDeformedMarkerGeometry(
              axialWidth,
              markerRadialHeight,
              circumferentialLength,
              cylinderRadius,
              markerCenterX,
              markerCenterAngle
            );
            const marker = new THREE.Mesh(markerGeom, markerMaterial);
            cylinderGroup.add(marker);
          }
        });
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      let lastTimestamp = 0;
      function animate(timestamp) {
        const delta = timestamp - lastTimestamp;
        // Throttle animation loop to save CPU in case monitor refresh rate is too fast
        const maxRefreshRateHz = 30;
        if (delta < 1000 / maxRefreshRateHz) {
          requestAnimationFrame(animate);
          return;
        }
        // Show actual refresh rate in console
        if (lastTimestamp !== -1) {
          const refreshRate = Math.round(1000 / delta);
          console.log(`Refresh rate: ${refreshRate} Hz`);
        }
        lastTimestamp = timestamp;

        cylinderGroup.rotation.x -= 0.005;
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }

      init();
    </script>
  </body>
</html>
