<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Rotating Cylinder with Deformed Markers</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.165.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.165.0/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      let scene, camera, renderer, cylinderGroup;
      let cylinder;

      const cylinderRadius = 5;
      const cylinderHeight = 20;
      const cylinderRadialSegments = 64;

      const markerColor = 0xaaaaaa;
      const markerRadialHeight = 0.1; // Thickness of the marker

      const minorMarkerCircumferentialLength = 0.5;
      const minorMarkerAxialWidth = 0.3; // Width along the cylinder's length

      const majorMarkerCircumferentialLength =
        minorMarkerCircumferentialLength * 1.6;
      const majorMarkerAxialWidth = minorMarkerAxialWidth * 1.4;

      const markerEndBuffer =
        Math.max(majorMarkerAxialWidth, minorMarkerAxialWidth) / 2 + 0.1;

      const markerMaterial = new THREE.MeshStandardMaterial({
        color: markerColor,
        metalness: 0.8,
        roughness: 0.3,
        // side: THREE.DoubleSide // Useful for debugging geometry
      });

      function createDeformedMarkerGeometry(
        axialWidth,
        radialHeight,
        circumferentialLength,
        baseCylinderRadius,
        markerCenterX,
        markerCenterAngle
      ) {
        const geometry = new THREE.BufferGeometry();

        const topRadius = baseCylinderRadius + radialHeight;
        const bottomRadius = baseCylinderRadius;

        // Calculate angular width based on the circumferential length at the marker's mid-radius
        const markerMidRadius = baseCylinderRadius + radialHeight / 2;
        const angularWidth = circumferentialLength / markerMidRadius;

        const angleStart = markerCenterAngle - angularWidth / 2;
        const angleEnd = markerCenterAngle + angularWidth / 2;

        const xStart = markerCenterX - axialWidth / 2;
        const xEnd = markerCenterX + axialWidth / 2;

        const vertices = new Float32Array([
          // Bottom face
          xStart,
          bottomRadius * Math.cos(angleStart),
          bottomRadius * Math.sin(angleStart), // p0
          xEnd,
          bottomRadius * Math.cos(angleStart),
          bottomRadius * Math.sin(angleStart), // p1
          xStart,
          bottomRadius * Math.cos(angleEnd),
          bottomRadius * Math.sin(angleEnd), // p2
          xEnd,
          bottomRadius * Math.cos(angleEnd),
          bottomRadius * Math.sin(angleEnd), // p3

          // Top face
          xStart,
          topRadius * Math.cos(angleStart),
          topRadius * Math.sin(angleStart), // p4
          xEnd,
          topRadius * Math.cos(angleStart),
          topRadius * Math.sin(angleStart), // p5
          xStart,
          topRadius * Math.cos(angleEnd),
          topRadius * Math.sin(angleEnd), // p6
          xEnd,
          topRadius * Math.cos(angleEnd),
          topRadius * Math.sin(angleEnd), // p7
        ]);

        // Order: p0, p1, p2, p3 (bottom from angleStart to angleEnd)
        //        p4, p5, p6, p7 (top    from angleStart to angleEnd)
        const indices = [
          // Bottom face (viewed from outside, e.g. under the cylinder, assuming CCW winding for outward normal)
          0,
          2,
          1,
          1,
          2,
          3, // If normals point "inward" to cylinder axis (traditional bottom)
          // For computeVertexNormals, consistent CCW when viewed from "outside" the marker volume
          // Let's use: 0,1,3, 0,3,2 (CCW from "below" marker, so normal points towards -Y local / towards cylinder axis)

          // Top face (CCW from "above" marker, normal points radially out from cylinder)
          4,
          5,
          7,
          4,
          7,
          6,

          // Side face at angleStart (CCW from "outside" that face)
          0,
          4,
          5,
          0,
          5,
          1,

          // Side face at angleEnd
          3,
          7,
          6,
          3,
          6,
          2, // Adjusted for CCW when looking at this face from outside

          // Side face at xStart (axial)
          2,
          6,
          4,
          2,
          4,
          0, // Adjusted

          // Side face at xEnd (axial)
          1,
          5,
          7,
          1,
          7,
          3,
        ];

        geometry.setAttribute(
          "position",
          new THREE.BufferAttribute(vertices, 3)
        );
        geometry.setIndex(indices);
        geometry.computeVertexNormals();

        return geometry;
      }

      function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);

        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(0, cylinderRadius * 1.2, cylinderHeight * 0.75); // Adjusted camera
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
        directionalLight.position.set(10, 15, 10);
        scene.add(directionalLight);
        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight2.position.set(-10, -5, -10);
        scene.add(directionalLight2);

        cylinderGroup = new THREE.Group();
        scene.add(cylinderGroup);

        const cylinderGeometry = new THREE.CylinderGeometry(
          cylinderRadius,
          cylinderRadius,
          cylinderHeight,
          cylinderRadialSegments,
          1,
          false
        );
        const cylinderMaterial = new THREE.MeshStandardMaterial({
          color: 0x228b22,
          metalness: 0.4,
          roughness: 0.7,
        });
        cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
        cylinder.rotation.z = Math.PI / 2;
        cylinderGroup.add(cylinder);

        createMarkers();

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        window.addEventListener("resize", onWindowResize, false);
        animate();
      }

      function createMarkers() {
        const numMajorMarkers = 5;
        const numMinorMarkersBetweenMajor = 4;
        const totalMarkersPerEnd =
          numMajorMarkers * (1 + numMinorMarkersBetweenMajor);
        const baseAngleIncrement = (2 * Math.PI) / totalMarkersPerEnd;

        const cylinderMarkerPlacementX = cylinderHeight / 2 - markerEndBuffer;
        const markerXPositions = [
          -cylinderMarkerPlacementX,
          cylinderMarkerPlacementX,
        ];

        markerXPositions.forEach((markerCenterX) => {
          for (let i = 0; i < totalMarkersPerEnd; i++) {
            const isMajor = i % (numMinorMarkersBetweenMajor + 1) === 0;

            const axialWidth = isMajor
              ? majorMarkerAxialWidth
              : minorMarkerAxialWidth;
            const circumferentialLength = isMajor
              ? majorMarkerCircumferentialLength
              : minorMarkerCircumferentialLength;

            const markerCenterAngle = i * baseAngleIncrement;

            const markerGeom = createDeformedMarkerGeometry(
              axialWidth,
              markerRadialHeight,
              circumferentialLength,
              cylinderRadius,
              markerCenterX,
              markerCenterAngle
            );
            const marker = new THREE.Mesh(markerGeom, markerMaterial);
            cylinderGroup.add(marker);
          }
        });
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        requestAnimationFrame(animate);
        cylinderGroup.rotation.x -= 0.005;
        renderer.render(scene, camera);
      }

      init();
    </script>
  </body>
</html>
