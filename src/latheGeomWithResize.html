<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Three.js Responsive Bevelled Cylinder</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      #container {
        width: 100vw;
        height: 100vh;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <div id="container"></div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";

      let scene, camera, renderer, cylinder;

      // The container div that our canvas will live inside.
      const container = document.getElementById("container");

      const maxRateHz = 30;
      let lastRateHz = maxRateHz;
      let lastTimestamp = -1;

      function init() {
        // ## Scene Setup ##
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);

        // ## Camera Setup ##
        // The initial camera setup. The aspect ratio and fov will be adjusted
        // dynamically by the ResizeObserver.
        camera = new THREE.PerspectiveCamera(
          75,
          container.clientWidth / container.clientHeight,
          0.1,
          1000
        );

        // ### FIX 1: Move the camera further away ###
        // The generated cylinder is quite large, so we need to move the camera
        // back to be able to see it.
        camera.position.z = 30;

        // ## Renderer Setup ##
        renderer = new THREE.WebGLRenderer({ antialias: true });
        container.appendChild(renderer.domElement);

        // ## Lighting ##
        const ambientLight = new THREE.AmbientLight(0x404040, 1.5); // Slightly increased intensity
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 10); // Moved light to better illuminate
        scene.add(directionalLight);

        // ## Cylinder Creation ##
        // Define the 2D points for the lathe geometry.
        // The x-value of the Vector2 is the radius, and the y-value is the height.
        // The expression `Math.sin(i * 0.2) * 10 + 5` created a large radius (~15).
        const points = [];
        for (let i = 0; i <= 10; i++) {
          const radius =
            i > 1 && i < 9 ? 2 + Math.sin(((i - 2) / 6) * Math.PI) * 0.5 : 2;
          points.push(new THREE.Vector2(radius, (i - 5) * 0.4));
        }

        const geometry = new THREE.LatheGeometry(points, 64);
        const material = new THREE.MeshStandardMaterial({
          color: 0x0077ff,
          roughness: 0.5,
          wireframe: true,
        });
        cylinder = new THREE.Mesh(geometry, material);

        // Orient the cylinder horizontally.
        cylinder.rotation.z = Math.PI / 2;
        scene.add(cylinder);

        // ## Responsive Resizing ##
        const resizeObserver = new ResizeObserver(onResize);
        resizeObserver.observe(container);

        // Initial resize call to set everything up.
        onResize();

        // Start the animation loop.
        requestAnimationFrame(animate);
      }

      function onResize() {
        if (!container) return;
        const width = container.clientWidth;
        const height = container.clientHeight;

        // ## Optimal Detail ##
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(width, height);

        // ## Maintain Camera Perspective ##

        // To ensure the rendered view is simply a magnified version of a smaller view,
        // we need to make sure that the visible area of the scene at a given distance
        // from the camera remains constant. In Three.js, the PerspectiveCamera's
        // vertical field of view (fov) and the canvas's aspect ratio determine what
        // is visible.
        // By keeping the visible height of the scene constant, we can adjust the fov
        // based on the canvas height.

        // To maintain the same perspective, we need to ensure that the
        // visible height of the scene at a certain distance remains constant.
        // We can do this by adjusting the camera's vertical field of view (fov)
        // based on the canvas height.

        // The desired visible height of the scene at the camera's z-position.
        const visibleHeight = 6;

        const fov = 2 * Math.atan(visibleHeight / (2 * camera.position.z));
        camera.fov = THREE.MathUtils.radToDeg(fov);

        camera.aspect = width / height;
        // It's crucial to call this after changing camera parameters.
        camera.updateProjectionMatrix();
      }

      function animate(timestamp) {
        // Throttle animation loop to spare the battery
        const delta = timestamp - lastTimestamp;
        const actualRateHz = Math.round(1000 / delta);
        if (actualRateHz < maxRateHz) {
          // Show actual refresh rate in console
          if (lastTimestamp !== -1 && actualRateHz !== lastRateHz)
            console.log(`Refresh rate: ${actualRateHz} Hz`);
          lastRateHz = actualRateHz;
          lastTimestamp = timestamp;

          // ## Animation ##
          if (cylinder) {
            // Spinning 'upwards' on its horizontal axis
            cylinder.rotation.x -= 0.005;
          }

          renderer.render(scene, camera);
        }

        requestAnimationFrame(animate);
      }

      init();
    </script>
  </body>
</html>
