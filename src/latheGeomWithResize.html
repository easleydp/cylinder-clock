<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Three.js Responsive Bevelled Cylinder</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #f0f0f0;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
      }
      #container {
        width: 80vw;
        height: 80vh;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <div id="container"></div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";

      let scene, camera, renderer, cylinder;

      // The container div that our canvas will live inside.
      const container = document.getElementById("container");

      const maxRateHz = 30;
      let lastRateHz = maxRateHz;
      let lastTimestamp = -1;

      let actualCylHeight;
      let actualCylWidth;
      let actualCylAspectRatio;

      function init() {
        // ## Scene Setup ##
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);

        // ## Camera Setup ##
        // The initial camera setup. The aspect ratio and fov will be adjusted
        // dynamically by the ResizeObserver.
        camera = new THREE.PerspectiveCamera(
          75,
          container.clientWidth / container.clientHeight,
          0.1,
          1000
        );

        // ### FIX 1: Move the camera further away ###
        // The generated cylinder is quite large, so we need to move the camera
        // back to be able to see it.
        camera.position.z = 30;

        // ## Renderer Setup ##
        renderer = new THREE.WebGLRenderer({ antialias: true });
        container.appendChild(renderer.domElement);

        // ## Lighting ##
        const ambientLight = new THREE.AmbientLight(0x404040, 1.5); // Slightly increased intensity
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 10); // Moved light to better illuminate
        scene.add(directionalLight);

        // ## Cylinder Creation ##
        // Define the 2D points for the LatheGeometry.
        // The x-value of the Vector2 is the radius, and the y-value is the height.
        // (Note: The lathe rotates around the Y axis so these points are for a
        // vertically oriented cylinder.)

        // // The expression `Math.sin(i * 0.2) * 10 + 5` created a large radius (~15).
        // const points = [];
        // for (let i = 0; i <= 10; i++) {
        //   const radius =
        //     i > 1 && i < 9 ? 2 + Math.sin(((i - 2) / 6) * Math.PI) * 0.5 : 2;
        //   points.push(new THREE.Vector2(radius, (i - 5) * 1.0));
        // }

        const points = generateBevelledCylinderPoints({
          radius: 2.5,
          height: 10,
          bevelSize: 0.08,
          bevelSegments: 2, // Use more segments for a smoother bevel
        });

        // Measure the cylinder for calculating the camera fov later (in onResize).
        // After orienting the cylinder horizontally, the actual height will be the max(x)*2
        // and the actual width will be max(y) - min(y)
        const extremes = getExtremes(points);
        actualCylHeight = extremes.maxX * 2;
        actualCylWidth = extremes.maxY - extremes.minY;
        // We don't want the cylinder rendered right up against the canvas edges
        actualCylHeight += 0.5;
        actualCylWidth += 1.5;

        actualCylAspectRatio = actualCylWidth / actualCylHeight;

        //console.log(points);
        const geometry = new THREE.LatheGeometry(points, 64);
        const material = new THREE.MeshStandardMaterial({
          color: 0x0077ff,
          roughness: 0.5,
          wireframe: true,
        });
        cylinder = new THREE.Mesh(geometry, material);

        // Orient the cylinder horizontally.
        cylinder.rotation.z = Math.PI / 2;
        scene.add(cylinder);

        // ## Responsive Resizing ##
        const resizeObserver = new ResizeObserver(onResize);
        resizeObserver.observe(container);

        // Initial resize call to set everything up.
        onResize();

        // Start the animation loop.
        requestAnimationFrame(animate);
      }

      /**
       * Generates a THREE.Vector2 array for a bevelled cylinder profile.
       *
       * This function creates the 2D profile (a cross-section) needed by
       * THREE.LatheGeometry to generate a 3D cylinder with bevelled top and
       * bottom edges. The profile is drawn along the positive X and Y axes,
       * centred vertically around the origin.
       *
       * @param {object} params - The parameters for the cylinder.
       * @param {number} params.radius - The radius of the cylinder.
       * @param {number} params.height - The total axial height of the cylinder.
       * @param {number} params.bevelSize - The size of the bevel (radius of the fillet).
       * @param {number} params.bevelSegments - The number of segments in the bevel's curve. More segments create a smoother curve.
       * @returns {THREE.Vector2[]} An array of THREE.Vector2 points for THREE.LatheGeometry.
       */
      function generateBevelledCylinderPoints({
        radius,
        height,
        bevelSize,
        bevelSegments,
      }) {
        const points = [];
        const halfHeight = height / 2;

        // Clamp the bevel size to prevent geometry errors
        const b = Math.min(bevelSize, radius, halfHeight);

        // --- Define the key vertices of the profile ---

        // P1: Top-center
        const p1 = { x: 0, y: halfHeight };
        // P2: Start of top bevel on the flat top surface
        const p2 = { x: radius - b, y: halfHeight };
        // P3: End of top bevel, start of the vertical side
        const p3 = { x: radius, y: halfHeight - b };
        // P4: End of the vertical side, start of the bottom bevel
        const p4 = { x: radius, y: -halfHeight + b };
        // P5: End of the bottom bevel, start of the flat bottom surface
        const p5 = { x: radius - b, y: -halfHeight };
        // P6: Bottom-center
        const p6 = { x: 0, y: -halfHeight };

        // --- Generate the points array by tracing the profile ---

        // Start at the top-center
        //points.push(new THREE.Vector2(p1.x, p1.y));
        points.push(new THREE.Vector2(p2.x, p2.y));

        // Generate the top bevel curve if the bevel is significant
        if (b > 0 && bevelSegments > 0) {
          const topBevelCenter = { x: p2.x, y: p3.y };
          for (let i = 1; i < bevelSegments; i++) {
            const angle = (Math.PI / 2) * (1 - i / bevelSegments);
            const x = topBevelCenter.x + b * Math.cos(angle);
            const y = topBevelCenter.y + b * Math.sin(angle);
            points.push(new THREE.Vector2(x, y));
          }
        }

        // Add the corner points that define the main cylindrical shape
        points.push(new THREE.Vector2(p3.x, p3.y));
        points.push(new THREE.Vector2(p4.x, p4.y));

        // Generate the bottom bevel curve
        if (b > 0 && bevelSegments > 0) {
          const bottomBevelCenter = { x: p5.x, y: p4.y };
          for (let i = 1; i < bevelSegments; i++) {
            const angle = -(Math.PI / 2) * (i / bevelSegments);
            const x = bottomBevelCenter.x + b * Math.cos(angle);
            const y = bottomBevelCenter.y + b * Math.sin(angle);
            points.push(new THREE.Vector2(x, y));
          }
        }

        // Add the final points to close the profile at the bottom-center
        points.push(new THREE.Vector2(p5.x, p5.y));
        //points.push(new THREE.Vector2(p6.x, p6.y));

        return points.reverse(); // We actually want the y coords going up
      }

      function getExtremes(points) {
        let maxX = -Infinity;
        let maxY = -Infinity;
        let minY = Infinity;

        for (let i = 0, len = points.length; i < len; i++) {
          const p = points[i];
          if (p.x > maxX) maxX = p.x;
          if (p.y > maxY) maxY = p.y;
          if (p.y < minY) minY = p.y;
        }

        return { maxX, maxY, minY };
      }

      function onResize() {
        if (!container) return;
        const width = container.clientWidth;
        const height = container.clientHeight;

        // ## Optimal Detail ##
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(width, height);

        // ## Maintain Camera Perspective ##

        // To ensure the rendered view is simply a magnified version of a smaller view,
        // we need to make sure that the visible area of the scene at a given distance
        // from the camera remains constant. In Three.js, the PerspectiveCamera's
        // vertical field of view (fov) and the canvas's aspect ratio determine what
        // is visible.
        // So we need to adjust the fov based on the canvas height.

        // The desired visible height of the scene at the camera's z-position.
        let visibleHeight = actualCylHeight;

        // Display with extra height if the aspect ratio isn't wide enough to display
        // the cylinder without clipping.
        const ctAspectRatio = width / height;
        if (ctAspectRatio < actualCylAspectRatio) {
          visibleHeight *= actualCylAspectRatio / ctAspectRatio;
        }

        const fov = 2 * Math.atan(visibleHeight / (2 * camera.position.z));
        camera.fov = THREE.MathUtils.radToDeg(fov);

        camera.aspect = width / height;

        camera.updateProjectionMatrix(); // crucial after changing camera parameters!
      }

      function animate(timestamp) {
        // Throttle animation loop to spare the battery
        const delta = timestamp - lastTimestamp;
        const actualRateHz = Math.round(1000 / delta);
        if (actualRateHz < maxRateHz) {
          // Show actual refresh rate in console
          //   if (lastTimestamp !== -1 && actualRateHz !== lastRateHz)
          //     console.log(`Refresh rate: ${actualRateHz} Hz`);
          lastRateHz = actualRateHz;
          lastTimestamp = timestamp;

          // ## Animation ##
          if (cylinder) {
            // Spinning 'upwards' on its horizontal axis
            cylinder.rotation.x -= 0.005;
          }

          renderer.render(scene, camera);
        }

        requestAnimationFrame(animate);
      }

      init();
    </script>
  </body>
</html>
